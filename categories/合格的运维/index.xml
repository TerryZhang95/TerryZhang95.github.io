<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>合格的运维 on 鸭鸭饲养员</title>
    <link>/categories/%E5%90%88%E6%A0%BC%E7%9A%84%E8%BF%90%E7%BB%B4/</link>
    <description>Recent content in 合格的运维 on 鸭鸭饲养员</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Thu, 19 Mar 2020 15:41:19 +1100</lastBuildDate>
    
	<atom:link href="/categories/%E5%90%88%E6%A0%BC%E7%9A%84%E8%BF%90%E7%BB%B4/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>linux开源驱动mac80211,ath9k开发笔记之发送tx</title>
      <link>/2020/03/linux%E5%86%85%E6%A0%B8%E6%97%A0%E7%BA%BF%E7%BD%91%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</link>
      <pubDate>Thu, 19 Mar 2020 15:41:19 +1100</pubDate>
      
      <guid>/2020/03/linux%E5%86%85%E6%A0%B8%E6%97%A0%E7%BA%BF%E7%BD%91%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</guid>
      <description>前言 框架介绍 ath9k的接口  ath9k发送的入口&amp;ndash; ath_tx   ieee80211的接口  ieee80211的入口   Reference  持续更新&amp;hellip;
前言 本文依据个人理解，也是结合在开发过程中遇到的坑和经验来进行的总结和分析。因为个人着重于ath9k的驱动开发，所以重点将围绕ath9k和mac80211展开。此文档的说明顺序和教科书也会有所差别，先从ath9k开始介绍，然后在追溯到mac80211，想当于由下至上的过程，希望能有所帮助。
框架介绍 ath9k传输和接收
 简单来看，发送阶段，userspace（linux内核）向下传的包，也就是所谓的sk_buff，会经过一系列的添加header和tailer的过程，最后进入mac80211 ath9k，也就是一种网卡的驱动，扮演在mac80211和网卡硬件之间的一个接口（API） ath9k会直接调度硬件上包的发送  ath9k的接口 ath9k发送的入口&amp;ndash; ath_tx 1 2 3  static void ath9k_tx(struct ieee80211_hw *hw, struct ieee80211_tx_control *control, struct sk_buff *skb)    从mac80211下来的包，会直接call到ath9k_tx这个api 在main.c中，定义了  1 2 3 4 5 6  struct ieee80211_ops ath9k_ops = { .tx = ath9k_tx, .start = ath9k_start, .stop = ath9k_stop, .</description>
    </item>
    
    <item>
      <title>Docker学习笔记</title>
      <link>/2020/03/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 11 Mar 2020 14:17:40 +1100</pubDate>
      
      <guid>/2020/03/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>安装 ubuntu 安装docker 1 2 3 4 5 6 7 8  sudo apt-get update sudo apt install apt-transport-https ca-certificates curl software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository &amp;#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&amp;#34; sudo apt-get update apt-cache policy docker-ce # 验证docker repo添加成功 sudo apt-get install docker-ce # 安装docker sudo systemctl status docker # 验证docker安装成功   ubuntu 安装 docker-compose 1 2 3  sudo curl -L &amp;#34;https://github.</description>
    </item>
    
    <item>
      <title>Shell脚本笔记</title>
      <link>/2020/03/shell%E8%84%9A%E6%9C%AC%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 10 Mar 2020 12:11:04 +1100</pubDate>
      
      <guid>/2020/03/shell%E8%84%9A%E6%9C%AC%E7%AC%94%E8%AE%B0/</guid>
      <description>变量  系统给定的特殊变量 自定义变量  判断变量是否为空     语法 基本算法  判断是否为数字 判断上一条命令是否执行成功 判断文件或文件夹是否存在 将多段文字写入文件 判断是否为空   Reference  变量 系统给定的特殊变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  $0	当前脚本的名字 $n	传递给脚本或者函数的参数，n表示第几个参数 $#	传递给脚本或函数的参数个数 $*	传递给脚本或函数的所有参数 $@	传递给脚本或者函数的所有参数 `$$`	当前shell脚本进程的PID $?	函数返回值，或者上个命令的退出状态 $BASH	BASH的二进制文件问的路径 $BASH_ENV	BASH的启动文件 $BASH_VERSINFO[n]	BASH版本信息，有六个元素 $BASH_VERSION	BASH版本号 $EDITOR	脚本所调用的默认编辑器 $EUID	当前有效的用户ID $FUNCNAME	当前函数名 $GROUPS	当前用户所属组 $HOME	当前用户家目录 $HOSTTYPE	主机类型 $LINENO	当前行号 $OSTYPE	操作系统类型 $PATH	PATH路径 $PPID	当前shell进程的父进程ID $PWD	当前工作目录 $SECONDS	当前脚本运行秒数 $TMOUT	不为0时，超过指定的秒将退出shell $UID	当前用户ID   自定义变量 1 2 3 4 5 6  #!</description>
    </item>
    
  </channel>
</rss>